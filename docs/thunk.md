<h2 id="thunk">组件函数调用的优化</h2>

在上面的示例中，根组件使用了两个 Counter 组件。
而 Counter 是一个函数，Counter 组件用一个函数调用来表示。
所以每次根组件重新渲染的时候，这两个组件函数都会被调用。

n1 状态改变时，n1 和 n2 关联的 Counter 组件函数都会调用。
n2 状态改变时也一样，两个 Counter 组件函数都会调用。
这里可以优化一下。让 n1 状态改变时，只调用 n1 关联的 Counter 组件函数，只更新相关的页面元素。
因为 n2 状态没有改变，执行 n2 关联的 Counter 组件函数是没有必要的。

这就要引入 thunk 这个概念。
一个 thunk 代表一个函数调用。
它不是立即执行的，而是通过对比另一个 thunk 的参数，如果两个 thunk 的参数一样，就不调用，而是直接使用相同参数的 thunk 的执行结果。
如果 thunk 的参数不一样，就执行函数调用，并将函数的返回值保存好，用于下一次比较。

框架提供了一个 `t` 函数，用于将普通函数调用转化为一个 thunk。
前面的示例中的根组件，可以改用 thunk：

```js
const app = new App(
  document.getElementById('app'),
  {
    n1: 0,
    n2: 0,
  },
  (state) => div(
    t(Counter,
      state.n1,
      (x) => state.$update('n1', x),
    ),
    t(Counter,
      state.n2,
      (x) => state.$update('n2', x),
    ),
  ),
);
```

就是将组件函数调用，改成 t 函数调用，并将组件函数作为第一个参数，其他组件参数不变。
t 函数返回一个 Thunk 类型的对象。

在首次渲染根组件时，因为没有可以比较的 thunk，所以两个 Counter 组件函数都会被调用。

然后点击 n1 关联的某个按钮，引起 n1 状态的变化，触发根组件的重新渲染。
这次会生成另外两个 thunk，然后各自和上一次渲染时生成的 thunk 比较。

n1 关联的 thunk，因为 state.n1 这个参数发生了变化，所以会重新调用 Counter 组件函数，并在页面上反映出 n1 变化的结果。

n2 关联的 thunk，因为 state.n2 没有变化，传入的匿名函数也没有变化
（函数类型的参数，只比较它们的名字，匿名函数名字都一样），所以不会调用 Counter 函数。

通过引入 thunk，实现了一个状态的改变，只会触发这个状态关联的组件的更新，不多也不少。
