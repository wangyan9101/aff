<h2 id="state-passing">组件状态的传递</h2>

与“状态树”这个概念类似，组件嵌套子组件，可以形成一颗“组件树”。

各个组件的状态，是从根组件开始，逐层传递到的。
所有子组件的状态，都需要从父组件接受的状态里得到。

必须这样做的原因是，子组件的渲染和更新过程，是父组件渲染和更新过程的一部分。
如果子组件使用了某个状态，但是没有传递给父组件，那这个状态改变时，不会引起父组件的更新，也就不会引起子组件的更新。

将状态传递给多层嵌套的组件时，需要将状态传入路径上所有的组件，示例：

```js
{{template "state-passing.js"}}
```

Element 需要 foo 状态，所以要从 Main -> OutterWrapper -> Wrapper -> InnerWrapper -> Element 这样逐层传递。

<h3>引用父状态</h3>

Element 如果需要多一个状态，那就要改动多处代码，逐层增加。减少一个状态也是一样，需要改动多处。相当不便。

框架对这种情况，提供了一个解决办法。先看最终的代码：

```js
{{template "state-passing-ref.js"}}
```

可以看出，传递给各个子组件的状态，定义在了初始状态里。
而且这些子状态的属性名，都与组件名相同，表明这是一个将传递给相应组件的状态。
在传递的时候，直接传递相应的子状态就可以了。
组件树和状态树的结构相同，就可以有这个便利。

另外，Element 组件的状态的 foo 成员，定义为 `ref('foo')`，代表它是一个引用。
它的意思是，向上寻找一个名为 foo 的状态，并逐层传递到这个状态对象里。
也就是说，OutterWrapper、Wrapper、InnerWrapper、Element 对应的这些状态对象，都会有一个 foo 属性，而且属性值和最外层的 foo 相同。
这就避免了手工逐层传递。

如果 Element 需要多一个状态，只需要增加相应的引用即可。
中间所有的组件的代码都不需要改动。
删除一个状态同理。

引用会从最内层，向最外层查找，直到根状态。如果到根状态都没有找到，就会抛出异常。
查找是初始化 App 的时候做的，不是在读取状态的时候。
所以从一开始就要在初始状态里定义好相关的状态。

引用的解析也只会在 App 初始化时做一次，后面 update 进状态树的不会解析。
因为解析引用开销比较大，如果更新一个大对象，就算不包含引用标记，也要进行解析的话，对性能影响比较大。

<h3>引用状态的直接赋值</h3>

包含引用属性的对象，直接对该属性赋值，可以改变引用指向的状态：

```js
{{template "ref-assignment.js"}}
```

因为 Sub.foo 指向的是一个字符串，是没有 $update 方法的，所以唯一更新它指向的状态的方式，也是直接赋值。

<h3>弱引用状态</h3>

引用一个状态，就代表引用指向的状态发生变化时，当前状态所关联的组件，也会重新渲染。
但有的时候，组件需要读或者写某个父状态，但又不需要观察它的变化，就要用到“弱引用”这个机制。

定义弱引用和定义引用类似，但函数使用的是 weakRef：

```js
{{template "weak-reference.js"}}
```

Element 组件引用了 foo 状态，但这是一个弱引用。
所以 Element 组件会渲染出 'foo'，点击按钮后，foo 状态更新为 'FOO'，但 Element 组件不会更新，因为它不会观察一个弱引用的状态。

当然，如果有其他方式触发 Element 组件的重渲染，它仍会渲染出当前的 foo 状态。

再来看一个这个机制的应用例子：

```js
{{template "delete-list-element.js"}}
```

Elem 组件有一个删除按钮，可以删除列表里对应的元素。

显然 Elem 组件需要引用 list 状态，才能对它进行 splice 操作。
但是如果将 list 状态作为引用传入 Elem 组件，那每次 list 发生变化时，都要重新渲染所有 Elem 组件。这是很不经济的。

弱引用就能发挥作用了，Elem 组件可以读写 list 状态，但 list 状态变化时，不会触发不必要的组件重渲染。

和强引用一样，可以对弱引用直接赋值，以更新指向的状态。

<h3>列表元素的传递</h3>

渲染一个列表是很常见的场景，框架提供了一个模式来处理。例如渲染一个用户列表：

```js
{{template "cached-and-wrap.js"}}
```

和上一节的 Elem 状态不同，上面定义的 User 状态是 cached(function(userId) { ... })。
使用的时候，用的是 t(User, state.User(id))，说明 cached 返回的是一个函数，而且这个函数的参数，和传入 cached 的函数，是一样的。

实际上，去掉 cached()，这样传递状态的方法，可能更好理解。就是遍历用户 id，并将 id 传入 User 函数，得到对应的用户信息，作为组件的参数。

cached 的作用是，将 User 函数的结果缓存起来，下一次传入相同的 id，就返回上一次调用的结果，而不需要重新调用。
因为 User 每次调用都是返回一个新的状态对象，所以会导致不必要的重渲染，用 cached 就可以避免。

User 函数首先通过 this.users[userId] 获得用户信息。函数中的 this，指向的是 User 属性所在的对象，这和 js 对象的函数类型的属性的绑定规则是一致的。

User 函数返回的是 wrap(user, { tag: ... })，代表 User 组件的状态，除了用户信息之外，还包括一个 tag 方法，用于改变 tagged 这个状态的值。

wrap 实际是创建了一个以 user 为原型的对象，并融合第二个参数的各个属性。
所以传入 User 组件的状态对象，会包含 user 的各个属性及方法（例如 $update 方法），以及扩展的 tag 方法。

如果 User 组件不需要 tag 等扩展的方法，可以直接返回 user 变量，不加 wrap。
