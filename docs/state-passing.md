<h2 id="state-passing">组件状态的传递</h2>

与“状态树”这个概念类似，组件嵌套子组件，可以形成一颗“组件树”。

各个组件的状态，是从根组件开始，逐层传递到的。
所有子组件的状态，都需要从父组件接受的状态里得到。

必须这样做的原因是，子组件的渲染和更新过程，是父组件渲染和更新过程的一部分。
如果子组件使用了某个状态，但是没有传递给父组件，那这个状态改变时，不会引起父组件的更新，也就不会引起子组件的更新。

将状态传递给多层嵌套的组件时，需要将状态传入路径上所有的组件，示例：

```js
{{template "state-passing.js"}}
```

Element 需要 foo 状态，所以要从 Main -> OutterWrapper -> Wrapper -> InnerWrapper -> Element 这样逐层传递。

Element 如果需要多一个状态，那就要改动多处代码，逐层增加。减少一个状态也是一样，需要改动多处。相当不便。

框架对这种情况，提供了一个解决办法。先看最终的代码：

```js
{{template "state-passing-ref.js"}}
```

可以看出，传递给各个子组件的状态，定义在了初始状态里。
而且这些子状态的属性名，都与组件名相同，表明这是一个将传递给相应组件的状态。
在传递的时候，直接传递相应的子状态就可以了。
组件树和状态树的结构相同，就可以有这个便利。

另外，Element 子状态里面有一个 $ref 成员，这是框架提供的特殊机制。
它的意思是，向上寻找一个名为 foo 的状态，并逐层传递到这个状态对象里。
也就是说，OutterWrapper、Wrapper、InnerWrapper、Element 对应的这些状态对象，都会有一个 foo 属性，而且属性值和最外层的 foo 相同。
$ref 指定的状态，是逐层传递的。
这就避免了手工逐层传递。

如果 Element 需要多一个状态，只需要在 $ref 里增加相应的属性名即可。
中间所有的组件的代码都不需要改动。
删除一个状态同理。

$ref 的定义也可以是一个对象，对象属性名对应设置的属性名，属性值对应需要查找的属性名：

```js
const init_state = {
  foo: 'FOO',
  OutterWrapper: {
    bar: 'BAR', 
    Wrapper: {
      InnerWrapper: {
        Element: {
          $ref: {
            FOO: 'foo',
            BAR: 'bar',
          },
        }
      }
    },
  }
};

// ...

const Element = (state) => div(state.FOO, state.BAR);

```

这样 Element 组件里用到的就是 FOO 和 BAR，而不是 foo 和 bar 了。

$ref 只会向上查找，直到根状态。如果到根状态都没有找到，就会抛出异常。
查找是初始化 App 的时候做的，不是在读取状态的时候。
所以从一开始就要在初始状态里定义好相关的状态。

$ref 的解析也只会在 App 初始化时做一次，后面 update 进状态树的不会解析。
因为解析 $ref 标记开销比较大，如果更新一个大对象，就算不包含 $ref 标记，也要进行解析的话，对性能影响比较大。

