<h2 id="state-passing">组件状态的传递</h2>

与“状态树”这个概念类似，组件嵌套子组件，可以形成一颗“组件树”。

各个组件的状态，是从根组件开始，逐层传递到的。
所有子组件的状态，都需要从父组件接受的状态里得到。

必须这样做的原因是，子组件的渲染和更新过程，是父组件渲染和更新过程的一部分。
如果子组件使用了某个状态，但是没有传递给父组件，那这个状态改变时，不会引起父组件的更新，也就不会引起子组件的更新。

将状态传递给多层嵌套的组件时，需要将状态传入路径上所有的组件，示例：

```js
{{template "state-passing.js"}}
```

Element 需要 foo 状态，所以要从 Main -> OutterWrapper -> Wrapper -> InnerWrapper -> Element 这样逐层传递。

Element 如果需要多一个状态，那就要改动多处代码，逐层增加。减少一个状态也是一样，需要改动多处。相当不便。

框架对这种情况，提供了一个解决办法。先看最终的代码：

```js
{{template "state-passing-ref.js"}}
```

可以看出，传递给各个子组件的状态，定义在了初始状态里。
而且这些子状态的属性名，都与组件名相同，表明这是一个将传递给相应组件的状态。
在传递的时候，直接传递相应的子状态就可以了。
组件树和状态树的结构相同，就可以有这个便利。

另外，Element 组件的状态的 foo 成员，定义为 `ref('foo')`，代表它是一个引用。
它的意思是，向上寻找一个名为 foo 的状态，并逐层传递到这个状态对象里。
也就是说，OutterWrapper、Wrapper、InnerWrapper、Element 对应的这些状态对象，都会有一个 foo 属性，而且属性值和最外层的 foo 相同。
这就避免了手工逐层传递。

如果 Element 需要多一个状态，只需要增加相应的引用即可。
中间所有的组件的代码都不需要改动。
删除一个状态同理。

引用会从最内层，向最外层查找，直到根状态。如果到根状态都没有找到，就会抛出异常。
查找是初始化 App 的时候做的，不是在读取状态的时候。
所以从一开始就要在初始状态里定义好相关的状态。

引用的解析也只会在 App 初始化时做一次，后面 update 进状态树的不会解析。
因为解析引用开销比较大，如果更新一个大对象，就算不包含引用标记，也要进行解析的话，对性能影响比较大。

